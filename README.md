#Morphing2D: Conditional VAE for Shape Morphing Generation
https://img.shields.io/badge/Python-3.8%252B-blue
https://img.shields.io/badge/PyTorch-2.0%252B-orange
https://img.shields.io/badge/OpenCV-4.5%252B-green

A deep learning framework that generates smooth 2D shape morphing sequences using Conditional Variational Autoencoders (CVAE), trained on SRVF-generated ground truth data.

ğŸ¯ Project Overview
This project implements a complete pipeline for learning-based shape morphing:

Data Generation: Extract contours and generate morphing sequences using SRVF

Model Training: Train Conditional VAE to generate morphing from source-target pairs

Evaluation: Compare learned morphing against mathematical SRVF baseline

ğŸ“ Project Files
morphing_2d_Data_generation.ipynb
Purpose: Generate training dataset with SRVF ground truth

Process:

Loads 2D geometric shapes from input data

Extracts contours using Canny edge detection

Generates optimal morphing sequences using Square-Root Velocity Function (SRVF)

Saves structured JSON dataset containing:

source_contour: Starting shape (200 points, 2D)

target_contour: Ending shape (200 points, 2D)

morphing_sequence: SRVF-generated ground truth (7 frames)

Output: morphing_dataset.json with 28,270 training samples

CVAE_for_morphing_generation.ipynb
Purpose: Train and evaluate Conditional VAE model

Process:

Loads JSON dataset generated by the first notebook

Implements Conditional VAE architecture:

Encoder: Maps sequences to latent space

Decoder: Generates sequences from latent codes + conditions

Condition: Concatenated source + target contours

Trains model using supervised learning (MSE loss against SRVF sequences)

Evaluates generated morphing using optical flow metrics

Compares against SRVF baseline

Output: Trained CVAE model and smoothness analysis

ğŸš€ Quick Start
1. Generate Training Data
Run morphing_2d_Data_generation.ipynb to:

Process geometric shapes from /kaggle/input/2d-geometric-shapes-17-shapes/

Generate SRVF morphing sequences

Create morphing_dataset.json

2. Train CVAE Model
Run CVAE_for_morphing_generation.ipynb to:

Load the generated dataset

Train Conditional VAE on source-target pairs

Generate new morphing sequences

Evaluate smoothness metrics

ğŸ“Š Performance Results
Smoothness Comparison (Lower is Better)
Method	Spatial Smoothness	Temporal Smoothness
SRVF (Ground Truth)	1.60	0.000001
CVAE (Our Model)	2.91	0.000064
Metric Definitions:

Spatial Smoothness: Movement coherence in space

Temporal Smoothness: Speed consistency between frames

ğŸ”¬ Technical Approach
Supervised Learning Framework
Input Condition: Source + target contours (800D)

Ground Truth: SRVF-generated sequences (7 frames Ã— 200 points Ã— 2D)

Model: Conditional VAE with 64D latent space

Loss: MSE reconstruction + KL divergence

Data Generation
Contour Extraction: OpenCV with 200-point resampling

SRVF Method: Mathematical interpolation guaranteeing smoothness

Dataset Scale: 28,270 source-target morphing pairs

ğŸ› ï¸ Dependencies
python
# Core libraries
torch>=2.0.0
numpy>=1.21.0
opencv-python>=4.5.0
matplotlib>=3.5.0
scipy>=1.7.0

# Additional utilities
scikit-image
tqdm
ğŸ“ˆ Key Insights
SRVF Advantage: Provides mathematically optimal smoothness as ground truth

CVAE Strength: Learns to generate morphing from data without manual correspondence

Trade-off: CVAE offers flexibility while SRVF guarantees smoothness

ğŸ® Usage Example
python
# After training, generate morphing between any two shapes
source = load_contour("circle.png")
target = load_contour("star.png")
morphing_sequence = cvae_model.generate(source, target)

# Visualize the 7-frame morphing sequence
plot_morphing_sequence(morphing_sequence)
ğŸ¤ Future Work
Improve CVAE smoothness with better temporal modeling

Explore transformer architectures for sequence generation

Extend to 3D shape morphing

Incorporate user constraints into morphing generation
